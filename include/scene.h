#pragma once 
#include "common.h" // 需要 Vec 定义
#include "aabb.h"
#include <string>
#include <vector>

// ======================================================================================
// 1. 基础枚举定义
// ======================================================================================

// [材质类型]
// 影响光线反弹的行为 (BSDF)
enum Refl_t { 
    DIFF, // 漫反射 (Diffuse): 朗伯余弦分布，模拟粗糙表面
    SPEC, // 镜面反射 (Specular): 完美反射，模拟镜子/金属
    REFR  // 折射 (Refractive): 斯涅尔定律 + 菲涅尔效应，模拟玻璃/水
};

// ======================================================================================
// 2. 物体结构体 (Object) - 极致内存布局优化
// ======================================================================================
// [优化策略]: 显存对齐 (Memory Alignment)
// GPU 读取显存的最佳粒度是 128位 (16字节)。
// 我们将所有 16字节对齐的 Vec 放在前面，将所有 4字节的标量 (float/int/enum) 放在最后凑整。
// 
// 这样排列后，Object 的大小正好是: 
// 16*6 (Vec) + 4*4 (Scalar) = 112 字节。
// 没有哪怕 1 个字节的 Padding 浪费！带宽利用率 100%。
// --------------------------------------------------------------------------------------
struct Object {
    // --- 16字节对齐的大块数据 (Vectors) ---
    
    // [三角形专用]
    // 为了支持网格模型，我们需要存储三个顶点。
    Vec v0, v1, v2; 

    Vec vn0, vn1, vn2; // [新增] 顶点法线 (用于平滑插值)

    // [材质属性]
    Vec albedo;   // 原来的 color。非金属的漫反射颜色 / 金属的反射颜色
    Vec emission; // 自发光强度 (Light Source)

    // --- 4字节的小块数据 (Scalars) ---
    // 将它们凑在一起，刚好填满一个 16 字节的 Cache Line
    
    float metallic;   // [0.0 - 1.0] 0=塑料/木头, 1=金属
    float roughness;  // [0.0 - 1.0] 0=光滑, 1=粗糙
    float ior;        // 折射率 (Index of Refraction), 玻璃=1.45, 水=1.33
    float transmission; // [0.0 - 1.0] 0=不透明, 1=玻璃

    // 还需要存纹理ID，这得另起一行了
    int tex_id; 
    int use_smooth;    // [新增] 1=使用平滑插值, 0=使用面法线
    
    // --- 3. 填充 (凑齐 160 字节) ---
    float pad1;
    float pad2;

};

// ======================================================================================
// 3. 全局配置与相机
// ======================================================================================

// [相机参数]
// 这个结构体在每一帧开始时由 CPU 传给 GPU Kernel。
// 包含生成光线所需的所有几何信息。
struct CameraParams {
    Vec pos; // 相机世界坐标
    Vec cx;  // 成像平面 X 轴 (已包含 FOV 缩放)
    Vec cy;  // 成像平面 Y 轴 (已包含 FOV 缩放)
    Vec dir; // 相机朝向 (归一化)
    
    float lens_radius; // 光圈半径 (Aperture / 2)。0 为针孔相机。
    float focus_dist;  // 焦距。光线在何处汇聚。
};

// ======================================================================================
// 4. 场景管理接口
// ======================================================================================

// 这是一个纯 CPU 端的数据容器，负责管理资源的生命周期。
// 使用 std::vector 可以方便地动态添加物体。
struct Scene {
    std::vector<Object> objects;
    std::vector<std::string> texture_files;

    AABB world_bound;
};

// 工厂函数
Scene create_cornell_box();
